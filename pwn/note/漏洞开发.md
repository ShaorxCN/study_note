# 漏洞开发

-  [1 整数溢出](#c1)
-  [1 基础知识](#c1)
-  [1 基础知识](#c1)


<div id=c1><h2>整数溢出</h2></div>

主要分为三种

1. 溢出 针对有符号数。因为最高位表示符号 但是有时候相加或者相减可能改变符号位。本身有of flag位可以标识计算结果是否产生了溢出。
2. 回绕 针对无符号数  比如0-1 再byte类型无符号数会变成255 255+1会变成0等
3. 截断 较大宽带数字被存入较小宽度操作数时高位被截断。比如 将259存入byte类型 因为byte只有8bit 变为3 



示例

```c
char buf[80];
void vulnerable()
{
    int len = read_int_from_network();
    char *p = read_string_from_network();

    if(len>80)
    {
        error("length too large:return");
        return;
    }

    memcpy(buf,p,len);
}
```

上面的例子看似检查了len 但是如果传入一个负数会通过检测  但是因为memcpy的第三个参数 size_t `typedef unsigned int size_t`。此时负数会被解释为一个很大的数字 从而产生栈溢出。


```c
void vulnerable()
{
    size_t len;
    char* buf;
    len = read_int_from_network();
    buf = malloc(len+5);
    read(fd,buf,len);
}
```

这里按照读取的长度而且加了5 但是可能遇到回绕溢出。这里size_t 虽然时无符号 但是如果len很大  那么容易产生回绕。比如32bit下 len=0xffffffff 那么len+5 就变为4了。 那么依旧还是会产生溢出。因为buf只申请了4字节。


```c
void main(int argc,char *argv[])
{
    unsigned short int total; 
    total = strlen(argv[1])+strlen(argv[2])+1;
    char *buf = (char *)malloc(total);
    strcpy(buf,argv[1]);
    strcpy(buf,argv[2]);
}
```

这个例子时因为使用了short来存储total 如果两个长度相加好过了ushort的上限 那么还是溢出

```C
// gcc -g -m32 -fno-stack-protector -z execstack overflow.c
// r `python -c 'print("A"*24+"B"*4+"C"*233)'`
#include <stdio.h>
#include <string.h>

void validate_passwd(char *passwd)
{
    char passwd_buf[11];
    unsigned char passwd_len = strlen(passwd);

    if(passwd_len>=4 && passwd_len <=8)
    {
        printf("good\n");
        strcpy(passwd_buf,passwd);
    }
    else
    {
        printf("bad\n");
    }
}

int main(int argc,char *argv[])
{
    validate_passwd(argv[1]);
    return 0;
}
```

反汇编发现pass_buf位置为ebp-14 这边没有canary 那么返回地址就是ebp+4那么就是0x18开始溢出返回地址。也就是24 那么就执行`r `python -c 'print("A"*24+"B"*4+"C"*233)'``

结果如下



```
gef➤  registers
$eax   : 0xffffcf14  →  "AAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCC[...]"
$ebx   : 0x41414141 ("AAAA"?)
$ecx   : 0xffffd300  →  "CCCCCCCCC"
$edx   : 0xffffd010  →  "CCCCCCCCC"
$esp   : 0xffffcf30  →  "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC[...]"
$ebp   : 0x41414141 ("AAAA"?)
$esi   : 0xf7fad000  →  0x001e3d6c
$edi   : 0xf7fad000  →  0x001e3d6c
$eip   : 0x42424242 ("BBBB"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
```
结果符合预期 但是eflags的结果有出入 这边overflow并没有置位