# linux安全机制

-  [1 基础知识](#c1)
    - [部分指令说明](#c1-1)
    - [部分概念说明](#c1-2)



<div id=c1-1><h2>部分指令说明</h2></div>


- 0 stdin 标准输入
- 1 stdout 标准输出
- 2 stderr 标准错误
- cmd>file 覆盖重定向
- cmd >> file 追加重定向
- cmd < tag 标准输入中读取 直到遇到tag
- cmd < file1 > file2 file作为cmd的标准输入并且输出到file2
- cmd 2 > file 将cmd的标准错误重定向并覆盖file
- 2 >& 1 将标注错误和标准输出合并

<div id=c1-2><h2>部分概念说明</h2></div>

linux 三种基本文件类型

1. 普通文件: 文本文件和二进制文件(所有其他文件)
2. 目录: 包含一组链接的文件 每个链接都将文件名映射到一个文件。这个文件也可能是目录
3. 特殊文件: 块文件 符号链接 管道 套接字等


/etc/group gid
/etc/passwd /etc/shadow

所有者-组权限-其他人权限

所有者u 所属组 g 其他人o 所有人a

chmod a+r file 增加所有人读权限
chmod u-w file 删除所有者写权限
chmod g=rwx file 指定所属组权限读写执行

当前终端下export 临时环境变量
修改配置文件的成为永久环境变量


/etc/profile 系统环境变量
~/.bashrc 用户环境变量


LD_PRELOAD 可以定义程序运行时优先加载的动态链接库。你可以通过设置 LD_PRELOAD 来改变程序对特定函数的调用，使其优先链接到你指定的共享库中的同名函数，而不是标准的库函数。

```
LD_PRELOAD=~/libc-2.23.so
```

这样程序就会优先加载当前用户目录下2.23的libc


environ 是libc中的全局变量  指向内存中的环境变量表。该表位于栈上。 linux下使用 pmap指令。

**procfss文件系统**

procfs（进程文件系统）是一种特殊的文件系统，它提供了一个以文件和目录的形式来表示正在运行的进程信息的接口。它通常被挂载在 /proc 目录下，允许用户和系统管理者访问进程相关的信息和状态。

在 Linux 系统中，procfs 提供了一个虚拟文件系统，它反映了内核中运行的进程和系统的当前状态。通过访问 /proc 目录下的文件和目录，您可以获取和修改进程的各种信息，例如进程的状态、命令行参数、打开的文件、内存映射、网络连接等。

以下是一些常见的在 /proc 目录中查看进程信息的文件和目录：
```
/proc/<PID>/status：包含有关进程的基本信息，如进程状态、父进程、线程数等。
/proc/<PID>/cmdline：包含进程的完整命令行参数。
/proc/<PID>/fd：代表进程打开的文件描述符。
/proc/<PID>/maps：列出了进程的内存映射信息，包括各个区域的起始地址、大小和权限等。
/proc/<PID>/net：提供有关进程网络连接的信息。
/proc/<PID>/auxv:传递给进程的解释器信息
/proc/<PID>/stack:进程的内核栈信息
/proc/<PID>/task:进程的线程信息
/proc/<PID>/maps:进程的内存信息
```
除了上述文件和目录，procfs 还提供了其他许多与进程相关的文件和目录，它们以进程的 PID 命名。您可以通过访问这些文件和目录来获取所需的进程信息。

**字节序**

大端序和小端序。x端序就是x位在内存的地位。大端序就是高位存储在内存的地位。针对byte级别的。如果字双字节 就按照这个重新排序。比如0x123456.这边大端序在内存中就是0x12 0x34 0x56 小端序则是0x56 0x34 0x12.


**调用约定**

- 内核接口
  - x86-32:
    1. 系统调用号：要调用的系统调用通过存储在 EAX 寄存器中的系统调用    号（syscall number）来指定。
    2. 参数传递：系统调用的参数传递通常使用寄存器进行。常见的参数传 递寄存器包括：EBX、ECX、EDX、ESI 和 EDI。具体使用哪些寄存器取决  于系统调用的参数数量和类型。
    3. 调用指令：使用 int 0x80 指令触发软中断来执行系统调用。执行该 指令时，CPU 会将寄存器中的重要数据保存并切换到内核模式，在内核中 处理系统调用。
    4. 返回值：系统调用完成后，返回值通常会存储在 EAX 寄存器中，以供    用户程序进行进一步处理。
  - x86-64:
    1. 系统调用号：要调用的系统调用通过存储在 RAX 寄存器中的系统调用号（syscall number）来指定。不同于 x86-32 架构，x86-64 使用更广泛的 RAX 寄存器来存储系统调用号。
    2. 参数传递：系统调用的参数传递通常使用寄存器进行。常见的参数传递寄存器包括：RDI、RSI、RDX、R10、R8 和 R9。具体使用哪些寄存器取决于系统调用的参数数量和类型。如果参数数量超过传递寄存器的数量，额外的参数将使用栈传递。
    3. 调用指令：使用 syscall 指令触发一个软中断来执行系统调用。执行该指令时，CPU 会将寄存器中的重要数据保存并切换到内核模式，在内核中处理系统调用。
    4. 返回值：系统调用完成后，返回值通常会存储在 RAX 寄存器中，以供用户程序进行进一步处理。
- 用户接口
    - x86-32:使用栈传递参数。参数由右到左的顺序入栈。然后call执行
    - x86-64:通过寄存器传递参数.也会使用栈，如果参数是memory类型。则通过栈传递参数。如果是INTEGER则寄存器。RDI、RSI、RDX、RCX、R8 和 R9
  
**核心转储**

使用ulimit设置。
