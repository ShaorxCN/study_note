# 源代码到可执行文件


包含内容
-  [1 编译](#c1)
    - [编译流程](#c1-1)
    - [GCC 编译实例](#c1-2)
-  [2 ELF文件](#c2)

</br></br></br></br>
<div id=c1><h2>编译原理</h2></div>


编译器功能主体如下图:

<img src="../image/compile.png"/>

<div id=c1-1><h3>编译流程</h3></div>
其中编译基本步骤如下图:

<img src="../image/compile_step.png"/>

1. 这边先读取源程序的`字符流`，编译器根据代码生成词素(lexeme),这里的词素就是代码中最小单位，不能继续分割 。举个例子:
    ```c
    a = b+c*60;
    ``` 
    这里生成的词素就是`a`, `=`, `b`, `+`, `c`, `*`,`60`,`;`.其中主要分为`保留字`,`标识符`,`常数`,`运算符`,`界符`。这里`界符`就是类似空白符，分号，括号等.然后根据这些词素会生成token表.比如`<id1,position>, <op1, =>`等。这些`id1`和`op1` 是一个示例 具体看实现。比如标识符的生成规则以及部分运算符定义。特别是标识符这边比如通过类似字母+数字的格式 也可以区分不同作用域的同名标识符。

2. 生成token也就是符号流之后会进行语法分析创建语法树
3. 然后根据符号表以及语法树判断是否符合语言规范并且收集类型想信息供后面作类型转换优化等。
4. 接下里就是生成对应语言的中间代码表示 例如三地址码。
5. 对中间代码进行优化
6. 根据优化后的代码根据目标机器生成对应的机器语言并优化。

这里提下三地址码：是一种常见的中间语言，类似汇编语言。每个指令组多存在三个操作数 所以成为三地址码。简单举个例子 `x=a op b` 这里就是最多的三个操作数a,b,和结果x.当然还有类似`x=y`的2操作数，`if x rop y goto l`则是如果`x relationop y` 则跳转l或者param m,call x,n的形式，这里就是将m设置为参数 然后x过程，n为参数个数。三地址码可以通过四元式来表示(运算符,操作数1,操作数2,结果)。其中不足的用下划线表示。比如`(param,m,_,_) (call,x,n,_)`.


<div id=c1-2><h3>GCC 编译实例</h3></div>


gcc编译主要分为 `预处理`,`编译` `汇编` `连接`四个主要步骤。

`预处理`这里通过`gcc hello.c -o hello -save-temps --verbose`保留中间文件并且打印详细信息。其中核心三条信息:
- `/usr/lib/gcc/x86_64-linux-gnu/10/cc1 -fpreprocessed hello.i ...(略过) -o hello.s` 这里通过`cc1`编译器实现了预处理以及编译两个步骤生成`hello.s`编译文件。其中还有个中间文件`hello.i`这是预处理后的文件。说明见`code/base/hello_test/hello.c`.

简单说明如下:

- 头文件展开：将源代码中以#include开头的行替换为对应的头文件内容。
- 宏替换：将源代码中以#define开头的行所定义的宏进行替换。
- 条件编译处理：根据源代码中以#if、#ifdef、#ifndef等开头的行对代码块进行条件编译处理。
- 注释处理：将源代码中的注释删除。
- 添加行号和文件名标识?

`编译` gcc我这边是17 默认AT&T汇编语法

`汇编`: `as -v --64 -o hello.o hello.s` `as`工具 根据机器指令和汇编代码对照表生成目标文件.此时还没有链接 因为虚拟地址未定。可以objdump查看

`链接`: ` /usr/lib/gcc/x86_64-linux-gnu/10/collect2 -plugin ...(略过) -o hello`。`collect2`命令。分为静态链接和动态链接两种。默认动态链接。这边包括地址和空间分配，符号绑定和重定位等操作。也即是分配虚拟地址以及对应页基址(分页内存管理下)。

<div id=c2><h2>ELF文件</h2></div>







