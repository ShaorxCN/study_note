内中断

cpu接收到中断信息后不再接着向下执行 而是处理这个特殊信息
中断信息分为内终端和外中断 这里讲的是内中断  外中断比如外部设备发起的 例如键盘鼠标等 是可以屏蔽的

8086 内中断情形     中断类型码
1.除法溢出          0
2.单步执行          1
3.执行into指令      4
4.执行int指令       n 比如之前用的21h

中断类型码 是一个字节的数据 cpu根据这个来做对应的处理  中断信息的来源称为中断源 

类似cs:ip的 设定  收到中断信息后要去找到对应处理程序的入口
8位的中断向量表纪录了对应中断程序的入口  中断向量就是中断程序的入口 
中断向量表保存在内存中 纪录了256个中断源所代表的中断程序的入口

所以问题变成了如何找到中断向量表
8086的中断向量表保存在内存地址0处从0000:0000到0000:03ff的1024个单元中。
一个表项存放一个中断向量 然后入口类似段地址加偏移地址 所以一个表项占2个字(4个字节) 高的字放段地址 低的字放偏移地址
所以n号中断源对应偏移地址的就在4N  段地址是4n+2
中断过程就是通过中断信息 中断类型码再中断向量表中找到对应程序的短地址和偏移地址 然后设置cs和ip这是cpu硬件完成的
过程如下：
1.从中断信息中取得终端类型码
2.标志寄存器入栈
3.设置tf(第八位)和if(第九位)为0
4 cs的内容入栈
5.ip的内容入栈
6.从4n和4n+2的位置读取数据并设置新的ip和cs

中断处理程序和iret指令
中断处理程序的常规步骤
1.保存用到的寄存器
2.处理中断
3.恢复用到的寄存器
4.用iret指令返回

iret指令 等价于
pop ip
pop cs
popf

单步中断过程
1.取得终端类型码 1
2.标志寄存器入栈  tf,if设置为0
3.cs,ip的内容入栈
4.ip=1*4,cs=1*4+2

响应中断的特殊情况
有时候收到中断信息也不会响应
比如 ss设置 因为ss 和 sp联动的 而且中断过程用到栈 所以不可能ss设置完成收到中断信息就立刻中断
这样会导致ss设置成功但是sp错误 后面的中断过程也就是错误的了


int指令
类似手动call某个内中断

1.取中断类型码n
2.标志寄存器入栈
3. if=0,tf=0
4。cs,ip的内容入栈
5.ip=n*4 cs=n*4+2

BIOS DOS中断例程的安装过程

1.开机 cpu通电 初始化cs=0ffffh ip=0 自动从ffff:0开始执行程序 ffff:0有一条跳转指令  cpu执行该指令后就转去执行bios的硬件检测和初始化程序
2.初始化程序建立bios所支持的中断向量  也就是各个中断例程的入口 这些例程都是固化在ROM中的 一直在内存中
3 2完成后 int 19h 进行操作系统的引导 然后计算机就交给操作系统了
4 DOS启动后 会将中断例程装入内存 并建立中断向量

一个中断例程中有个多个子程序，bios和dos都是通过ah的值来传递内部子程序的编号

例如bios的int 10h 光标位置
mov ah,2   ;置光标子程序
mov bh,0   ; 第零页
mov dh,5   ;行号5
mov dl,12  ;列号12
int 10h


