基础原则:

- Secure By Default
  - 黑名单白名单:优先白名单 因为事物发展 特定时期内的黑名单无法覆盖未来发展
  - 最小权限原则:不要过度授权 通配谨慎
- 纵深防御原则:多层次 不同方案配合使用。
- 数据代码分离：其中比较重要的就是模板/标准和变量分离。这里模板就是代码 变量就是数据。
- 不可预测性原则:数据不要规律化。比如id如果只是单纯数字id自增 那么必然可以预测到后面文章的id.就可能涉及攻击入侵。


1. [浏览器安全](#c1)
2. [跨站脚本攻击xss](#c2)
3. [跨站点请求伪造csrf](#c3)
4. [点击劫持 clickjacking](#c4)
5. [HTML5安全](#c5)


<h2 id= c1>浏览器安全</h2>

同源策略:host/ip 子域名 端口 协议 这些都一致才是同源。这是针对页面的。在页面中引入非永远的js不算。比如各种资源使用cdn等。
类似 img iframe script等标签中通过src可以引入非同源资源。但是有一定限制 比如javascript对返回资源的访问读写受限。

但是IE8 类似在parse css过程中可以越过类似限制

多进程架构 功能隔离 sandbox隔离  evssl证书  黑名单限制



<h2 id= c2>跨站脚本攻击xss</h2>

xss 类型

1. 反射型xss:简单就是将数据发射给浏览器 相对的就是下面的存储型xss
2. 存储型xss:将非法获得的用户数据存储在服务端
3. DOM Based xss:  有点类似ROP?通过从DOM结构中不同部分的内容形成反射型xss。不过这边内容可以自己操控一部分


xss payload:类似js脚本。比如创建img 节点 但是src是某请求以及带上参数。那么就会在渲染的时候直接请求

Samy Worm  xss worm实例

xss 防御:

1. httpOnly:禁止js访问带有httpOnly的cookie
2. 输入输出检查:类似敏感词的过滤以及转义
  

<h2 id= c3>跨站点请求伪造csrf</h2>
其中一种攻击方式就是利用cookie发送。比如同一个域 blog.诱使用户访问我们的页面。我们页面中有个img一类可以跨域的标签。其中src改为某个请求。此时会自动带上cookie 成功。

一种session cookie ：无过期时间 跟随浏览器生命周期。关了就没了
一种本地cookie(第三方cookie)：设置了过期时间。存储在本地。某些浏览器比如ie6,7,8等会禁止在可跨域标签img等中发送这类cookie

P3P header 可以越过上面说的限制。

上面img默认是get请求，但是目标src中可以通过js创建post请求。


csrf的本质就是攻击者通过请求的结构以及部分参数可预测(比如自增 比如用户名id等明文)能够伪造出合法的请求url。这样如果使用类似加密或者url 加token干扰 等可以防御。比如在cookie中加token 然后请求中获取加入url参数中/放入表单请求中。服务端检测session中的token和请求中是否一致即可。上述攻击核心其实是构造请求然后让用户浏览器自动发送cookie。攻击者是没有cookie的。不过其他方式先获取cookie并且知道防御策略还是可以绕过。还有就是如果放在url中防止referer泄露。比如攻击者构造一个跨域请求 会将url中的token以referer url的形式泄露。



<h2 id= c4>点击劫持 clickjacking</h2>

比如透明iframe 。这样用户会误点。
<h2 id= c5>HTML5安全</h2>

依照之前原则 白名单机制。因为和名单机制无法预测未来技术的发展。这里就设计html5中产生的新标签。



