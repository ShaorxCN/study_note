1. [注入攻击](#c1)
2. [文件上传](#c2)
3. [认证与会话管理](#c3)
4. [访问控制](#c4)
5. [加密算法和随机数](#c5)


<h2 id= c1>注入攻击</h2>

sql注入:常规就是将部分恶意sql语句作为参数拼接进去。比如前半段是语句然后分号截断。后面则是另外一条语句。

```sql
select * from xxxx where aaa = 'bbb';drop table xxxx--`
```

其中本来作为传递参数的值被填写为 

```sql
bbb';drop table xxx--
```

其中`--`和`#`类似 用于注释最后代码拼接上的单引号.解决单引号的报错

如果网站会回显错误 可以方便我们获取类似查询条件字段 数据库类型等信息。如果没有的话则只能通过盲注的方式进行。就是通过拼接类似 and 1=1 或者 1=2这种必定成功或者必定失败的条件语句。看站点能否执行。由此确定是否存在漏洞。然后就是通过盲注技巧来确定库名。

Timing attack.就是利用部分数据库特性执行类似代码。比如mysql 中的benchmark.

```sql
benchmark(count,expr) # 是将expr执行count次数


1170 UNION SELECT IF(SUBSTRING(current,1,1) = CHAR(119),BENCHMARK(500000,ENCODE('MSG','by 5 seconds')),null) FROM (Select Database() as current) as tbl
```

其中通过遍历26个字母来判断库名。如果命中则执行benchmark 这样返回时间较长则确定命中。


pg中类似 GENERATE_SERIES(START,STOP,STEP) STEP缺省默认为1。这是按照按照步长生成一个`[start,stop]`的数字序列。



#### 常见的攻击技巧

例如通过拼接 union all select 1,2 from admin 这种来确定是否存在admin表。 可以通过[sqlmap.py](https://github.com/sqlmapproject/sqlmap) 来自动化过程


如何防御: 
1. 使用预编译语句 这个数据库支持 首先生成模板 然后将变量指定。不会被修改定义。
2. 存储过程 类似预编译语句 
3. 检查数据类型
4. 使用安全函数


其他xml注入 代码注入 crlf（\r\n 0x0d 0x0a）注入等原理类似 特别是crlf http中head 和 body是通过crlf两次分割的

<h2 id= c2>文件上传</h2>

主要原理是通过上传web脚本被服务器解析。

前提主要两个：
1. 是可以上传含有脚本的文件且不被安全检查格式化压缩等 
2. 上传后能够被访问且能够被web容器解释执行


对于第一点。比如检查文件后缀名。可以通过修改post数据包 在文件名后面增加0x00 也就是对于c等语言中字符串结束符。这样形成的文件变为xxxx.cgi[\0].jpg 。此处绕过前端文件名检查 但是在后端文件名解析的时候会变为cgi文件。 还有就是解析文件头。文件都可以通过文件头来确定类型。可以将攻击的文件头插入在可以通过检查的文件头后。


防御方法：
1. 设置上传文件目录不可执行
2. 检查文件类型
3. 使用类似随机id等改写文件名和路径
4. 单独设置文件服务器的域名



<h2 id= c3>认证与会话管理</h2>

认证 单因素 双因素 多因素认证。

一般登录凭证是密码 这边意识密码复杂度要求 还有就是弱密码列表提示。密码需要以不可逆的算法处理后存储。比如之前常见的md5.之前常规破解就是通过彩虹表查询。这里还是可以通过增加salt再md5的形式增加攻击难度。

单密码认证就是单因素认证。

密码一般都是在初次登录时校验。登录成功后一般通过类似session等形式作为凭证。这里可能就涉及到cookie(比如sid加密保存在cookie).获取cookie则相当于获取了凭证。特别是本地cookie.

然后又涉及到session保持攻击。关于session过期问题。如果策略是session只要被使用就重置过期时间，那么sessionid被盗窃后就会造成很严重的安全隐患。

防御方法:
1. session强制过期
2. 检测请求来源信息 比如和登录时候的ip useragent对比
3. session唯一性。比如再被盗后 如果又重新登录请求通过 则原来的失效

<h2 id= c4>访问控制</h2>

上节的凭证认证的是身份。访问控制则是权限。登录代表你能进来。权限则是你能做什么。

主体对客体能做什么。比如linux 就是某用户对某文件能做什么(r w x)

RBAC role-based-access-control。基于角色的访问控制。 用户-角色-权限。 用户可以拥有一个或者多个角色。每个角色则拥有对应的权限。也可以称之为垂直权限管理。

补充的则是水平权限管理。RBAC还需要做一些补充。比如用为普通用户角色可以访问自己的订单信息。当时多个普通用户角色不能交叉访问。不然就是越权。这里的角色只是检查了是否能够访问订单信息。但是没有校验某订单是否属于某用户。所以除了角色校验还需要做基于数据的访问控制。就是水平权限管理。



#### OpenID以及OAuth

OpenID解决的是认证问题。通过统一的集中认证系统。登录的时候通过提供openid跳转到openid提供者处统一认证在跳转回来。OAuth则是更加注重授权。可以在不提供某些凭证的情况下获取第三方的某些资源。比如现在创建的qq或者微信登录。这边并不会需要我们向目标站点提供qq登录信息。而是带上请求的资源信息(包括目标站点自己的身份信息等)来到qq自己的认证平台。登录通过后会询问我们是否同意目标站点获得这些资源的权限。我们同意后则目标站点获得。

这里一个OAuth 2.0最常用的授权码模式流程,其中资源拥有者是用户。第三方站点为客户端 然后微信作为服务提供商 并且提供认证服务器和资源服务器。

1. 客户端带上授权请求信息以及重定向回来的uri 引导用户到授权服务器。(这里如果没有登录凭证则需要用户在服务商那儿登录)
2. 用户同意则返回授权码并跳转回指定的客户端uri。这样第三方站点后台获取到code后带上同样的重定向uri向认证服务器申请令牌
3. 认证服务器认证通过则发放令牌以及刷新令牌(刷新令牌有效时间较长 令牌失效后可以通过刷新令牌重新申请令牌 推荐刷新令牌一次性 刷新后返回新的访问令牌和刷新令牌以供下次使用。但是可以保留原来刷新令牌的有效剩余时间)
4. 客户端获得token后可以带着令牌向资源服务器申请资源。


<h2 id= c5>加密算法和随机数</h2>

分组加密算法和流密码加密算法

#### 分组加密算法（Block Cipher）

原理:分组加密算法将明文分成固定长度的块（通常是128位或64位），然后对每个块进行独立加密。常见的分组加密算法包括AES（高级加密标准）和DES（数据加密标准）。

工作模式:分组加密算法有多种工作模式，用于处理块之间的关系。常见的模式包括：

电子密码本模式（ECB）：每个明文块独立加密，不同块之间没有联系。
缺点：相同的明文块加密后得到相同的密文块，容易被攻击。

密码分组链接模式（CBC）：每个明文块在加密前与前一个密文块进行异或操作，第一个块与初始向量（IV）异或。
优点：相同的明文块在不同位置加密后会得到不同的密文块。

计数器模式（CTR）：使用一个计数器生成密钥流，然后将密钥流与明文块进行异或操作。
优点：可以并行加密和解密。

密文反馈模式（CFB） 和 输出反馈模式（OFB）：这两种模式将分组密码转换为流密码模式，用于加密不满一个块的数据。

应用场景:分组加密算法通常用于加密存储数据，如磁盘加密、文件加密，以及加密传输数据时的数据块加密。

优点:可以处理大块数据。多种工作模式可选，提供灵活性。

缺点:加密和解密处理一个块的数据需要固定的时间，不适合实时加密。
数据长度需要是块大小的整数倍，不足时需要填充（padding）。


#### 流密码加密算法（Stream Cipher）

原理:流密码加密算法将明文按字节或按比特逐位加密，生成一个伪随机的密钥流，然后将密钥流与明文进行异或操作。常见的流密码算法包括RC4和ChaCha20。

应用场景:流密码算法适用于实时加密、数据流加密，如网络通信加密（如TLS/SSL中的RC4）和无线通信（如WEP中的RC4）。

优点:适合加密数据流，延迟低，适用于实时加密。不需要填充，适合任意长度的数据。

缺点:如果密钥流重复使用，容易被攻击。密钥管理复杂，需确保密钥流的随机性和唯一性。

其中针对流密码加密算法：

因为e(a) = a xor key  e(b) = b xor key

那么 e(a) xor e(b) = a xor key xor b xor key = a xor b xor key xor key = a xor b

e(a) e(b)为密文一般公开。那么仅需要a就可以得出b

这样攻击者可以自己申请用户 或者a 以及 e(a) 那么b e(b)中知道任意一个就可以知道另外一个。并不需要知道key了。当然前提是使用的key不变。当然也可以通过mac校验。其中使用较多的为hmac.


#### HMAC的基本原理

HMAC 使用一个加密哈希函数（如 SHA-256）和一个秘密密钥来生成消息认证码。其主要步骤如下：

选择一个哈希函数：通常使用的哈希函数包括 MD5、SHA-1、SHA-256 等。

准备密钥：如果密钥的长度大于哈希函数的块大小（如 SHA-256 的块大小是 64 字节），则将密钥进行哈希处理。如果密钥的长度小于哈希函数的块大小，则用零填充到块大小。

生成两个固定长度的密钥：

- ipad（内填充）：密钥和块大小的字节值 0x36 进行异或操作。
- opad（外填充）：密钥和块大小的字节值 0x5c 进行异或操作。

计算 HMAC：首先，将 ipad 和消息拼接在一起，然后对结果进行哈希运算。然后，将 opad 和上述步骤的哈希结果拼接在一起，并再次进行哈希运算，最终得到 HMAC 值。


HMAC公式:

HMAC(K,m)=H((K⊕opad)∥H((K⊕ipad)∥m))


其中：
- H 是所使用的哈希函数。
- K 是密钥。
- m 是消息。
- ∥ 表示连接操作。
- ⊕ 表示按位异或操作。
- ipad 是块大小字节的 0x36。
- opad 是块大小字节的 0x5c。

HMAC 的优点

- 消息认证：确保消息来自于合法发送者，并且在传输过程中未被篡改。
- 使用简单：基于现有的哈希函数，容易实现。
- 安全性高：抵抗已知的攻击方式，包括碰撞攻击、扩展攻击等。


还有就是伪随机数。不讨论语言 可以使用/dev/random或者 /dev/urandom生成随机数

```C
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    int randomData = open("/dev/random", O_RDONLY);
    if (randomData < 0) {
        perror("Failed to open /dev/random");
        return 1;
    }

    int myRandomInt;
    ssize_t result = read(randomData, &myRandomInt, sizeof(myRandomInt));
    if (result < 0) {
        perror("Failed to read from /dev/random");
        close(randomData);
        return 1;
    }

    close(randomData);

    printf("Random integer: %d\n", myRandomInt);

    return 0;
}
```