# 高级篇开始

包含内容
-  [1 基础功能以及新特性](#c1)
-  [2 地址空间](#c2)


<div id=c1><h2>基础功能以及新特性</h2></div>
这部分主要是名词以及概念介绍。

**运行模式:**

- 实模式（Real-Address Mode）。它为处理器提供Intel 8086处理器的运行环境，并追加了保护模式和系统管理模式的切换扩展。(16bit 寻址是20bit)
- 保护模式（Protected Mode）。它是32位处理器的主要运行模式，为软件的运行提供了丰富的功能、严格的安全性检测以及向后兼容性。
- 系统管理模式（System Management Mode，SMM）。它是32位处理器的标准功能，提供一种对操作系统透明的机制来执行电源管理和OEM的特殊功能。一旦切换至SMM模式，处理器将进入一个隔离的地址空间运行。
- 虚拟8086模式（Virtual-8086 Mode）。它是处理器为保护模式提供的一种准运行模式，允许处理器在保护模式下执行8086软件和多任务环境。
- IA-32e模式（IA-32e Mode）。它是64位处理器的主要运行模式，共包含两种子模式：兼容模式和64位模式（64-bit Mode）。64位模式为处理器提供64位的线性地址空间并支持超过64 GB的物理地址寻址，而兼容模式可使大部分保护模式的应用程序无修改运行于64位处理器中。

下面是几种模式的切换的流程图:

<img src="./img/pattern_switch.png"></br>

**总结下**
1. **系统保护模式**是一种特殊模式 ，不管出于什么模式，当收到`SMI`信号就会进入系统管理模式。收到`RSM`则会返回之前的模式
2. **实模式**，通电或者重启后首先运行实模式。然后`cr0`的`PE(bit[0])`位置`1`进入**保护模式**
3. **保护模式**在开启分页的场景下(cr0.PG=1)，置位IA32_EFER寄存器的LME标志位（位于IA32_EFER寄存器的第8位）可使处理器进入**IA-32e模式**.
4. 通过IA32_EFER寄存器的LMA标志位（位于IA32_EFER寄存器的第10位）可以判断处理器是否运行在IA-32e模式下。当处理器运行于IA-32e模式，代码段描述符的L标志位可确定处理器运行于64位模式还是兼容模式
5. EFLAGS标志寄存器的VM标志位可使处理器在保护模式与**虚拟8086模式**间切换


IA-32模式下通用寄存器：EAX EBX ECX EDX ESI EDI ESP EIP

下图是通用寄存器的特殊功能

<img src="./img/register_useful.png"></br>

IA-32e 64bit下:RAX RBX RCX RDX RSI RDI RSP RIP以及R8-R15 16个通用寄存器

在非64位模式下，通用寄存器的高32位处于未定义状态，当处理器从64位模式切换至32位模式（保护模式或兼容模式）时，任何通用寄存器的高32位数据都不会保留，因此软件不能依靠这种方法来保存数值。


**CPUID指令:**

CPUID汇编指令用于鉴别处理器信息以及检测处理器支持的功能，它在任何模式下的执行效果均相同。通过EFLAGS标志寄存器的ID标志位（位于EFLAGS寄存器的第21位）可检测出处理器是否支持CPUID指令。如果处理器支持CPUID指令，那么软件可自由操作ID标志位。

cpuid使用`eax`寄存器作为主功能号输入,`ecx`作为子功能号输入(需要的话)。使用`eax ebx ecx edx`保存执行结果。在64位模式下这些信息依然是32位的，因此处理器只使用RAX、RBX、RCX以及RDX寄存器的低32位保存执行结果，而高32位则被清0。
cpuid可以查询两类信息。基础信息和扩展信息:

- 基础信息： 主功能号从`0h`开始 最大支持到`14h` 通过`0h`可以查询到支持的最大基础功能号
- 扩展信息:  主功能号从`80000000h`开始，最大支持`80000008h`.`80000000h`可以查询处理器当前支持的最大扩展功能号。

下面是intel 关于cpuid的指令表达方式

<img src="./img/cpuid.png"></br>


**标志位寄存器:**

EFLAGS标志寄存器包含有状态标志位、控制标志位以及系统标志位，处理器在初始化时将EFLAGS标志寄存器赋值为00000002h。在IA-32e体系结构中，EFLAGS标志寄存器已从32位扩展为64位，其中的高32位保留使用。图6-3描绘了RFLAGS标志寄存器各位的功能，其中的第1、3、5、15以及22~63位保留使用。由于64位模式不再支持VM和NT标志位，所以处理器不应该再置位这两个标志位。(虽然处理器允许软件置位NT标志位，但执行IRET指令将触发#GP异常)

下图是标志位说明:

<img src="./img/eflags.png"></br>

当程序通过调用门执行任务切换的时候，处理器会把eflags的值保存到任务状态段tss内，并将目标任务状态段tss内的值更新到efalgs标志寄存器中。（这里应该属于硬件切换的tss）

eflags 分为状态标志，方向标志，和IOPL区域几个部分:

**状态标志**:eflags寄存器的状态标志 0,2,4,6,7,11
  - **CF**(bit[0] carry flag  进位 无符号整型结果的溢出状态 是否发生进位或者借位。0:无 1:有))
  - **PF**(bit[2] Parity flag 奇偶 计算结构的奇偶校验  0：奇数个1 1:偶数个1)
  - **AF**(bit[4] Auxiliary carry flag 辅助 用于BCD算术运算 0:未发生进位或者借位 1：发生)
  - **ZF**(bit[6] zero flag 零值  计算结果是否为0 0:否 也就是1  1：是  也就是计算结果为0)
  - **SF**(bit[7] Sign flag 符号 反映有符号数运算结果的正负值 0：正值 1:负值)
  - **OF**(bit[11] Overflow flag 溢出 反应有符号加减法计算结果的溢出状态  0：无溢出 1：溢出)

如图:

<img src="./img/state_flag.png"></br>

这里 AF表示的是BCD的进位借位。然后CF和OF 针对的是无符号数和有符号数的。有符号数的OF可以来表示是否计算产生符号位的翻转。比如正数加正数=负数。CF则是是否结算结果超出算术逻辑单元长度的进位。比如32bit的结果进位到了33bit。然后cf可以用过STC（set cf 1） CLC(clear cf 0)和CMC(complement carry flag cf取反)指令更改值。它也可借助位操作指令（BT、BTS、BTR和BTC指令）将指定位值复制到CF标志位。而且，CF标志位还可在多倍精度整型数计算时，结合ADC指令（含进位的加法计算）或SBB指令（含借位的减法计算）将进位计算或借位计算扩展到下次计算中。至于状态跳转指令Jcc、状态字节置位指令SETcc、状态循环指令LOOPcc以及状态移动指令CMOVcc，它们可将一个或多个状态标志位作为判断条件，进行分支跳转、字节置位以及循环计数。

**方向标志**:DF bit[10] 控制着字符串指令(例如:movs,cmps,scas,lods,stos等)的操作方向。df=1 则是自减 操作。df=0则是自增。同理 STD CLD

**系统标志和IOPL区域**:，负责控制I/O端口地址访问权限、屏蔽硬件中断请求、使能单步调试、任务嵌套以及使能虚拟8086模式等。表6-3记录着各系统标志位和IOPL区域的功能。需要0特权级。

如下图:

<img src="./img/iopl.png"></br>
VIF和VIP标志位只在Virtual-8086模式中有效；AC标志位只能对3特权级的数据进行对齐检测，如果发现数据未对齐则触发#AC异常；置位RF标志位将临时禁止断点指令触发#DB异常；IF标志位对NMI（Nonmaskable Interrupt，不可屏蔽中断）不起作用。我们可借助汇编指令CLI、STI、POPF、POPFD和IRET操作IF标志位。（处理器会参考CPL、IOPL和CR4.VME标志位，来确定不同场景下的指令执行权限。）



**控制寄存器:**

目前 intel处理器 6个控制寄存器:(CR0,CR1,CR2,CR3,CR4以及CR8)。
简单讲 cr0控制处理器的状态以及运行状态，cr2存储#PF的线性地址 cr3存储页目录的物理基地址以及属性。cr1 保留 具体见下图:

<img src="./img/cr.png"></br>


在IA-32体系结构下，控制寄存器的位宽是32位，而IA-32e体系结构会将控制寄存器扩展至64位宽。但是除地址类寄存器外，其他扩展位均作保留使用，且必须写入0。具体见下图:

<img src="./img/cr_detail.png"></br>

通过MOV CRn汇编指令可对控制寄存器进行操作，其中的保留位必须写入数值0，否则会触发#GP异常。CR2和CR3控制寄存器不会对写入的地址进行检测（物理地址与线性地址均不检测）；CR8控制寄存器只在64位模式下有效。具体功能bit说明:

<img src="./img/cr_bit1.png"></br>
<img src="./img/cr_bit2.png"></br>

CD（cache disable）控制系统内存的缓存机制(0 启用高速缓存 1 关闭) 

NW(not write-through)控制系统内存的写穿机制(0 代表 写穿 1 代表写回)。两者联合控制处理器的缓存策略和读写策略。

cpu使用高速缓存的时候 对内存的写操作两种模式：写穿(写cache也邪写内存  操作简单 但是缓存只是读缓存)和写回（对内存写数据不直接写 而是写入cache 当cache被替换出去才写回内存 cache速度远大于RAM(主存)。通过DCache吸收系统的写操作，在必要的时候再统一写入主存，从而减少频繁的相对较慢的对主存的写操作，这样明显能加速系统）

cd和nw的联合功能代表如下：

<img src="./img/cdnw.png"></br>

浮点处理cr0

<img src="./img/cr_float.png"></br>


EFER寄存器如下图:

<img src="./img/efer.png"></br>
<img src="./img/eferbit.png"></br>


**MSR寄存器组:**

MSR（Model-Specific Register）寄存器组可提供性能监测、运行轨迹跟踪与调试以及其他处理器功能。在使用MSR寄存器组之前，我们应该通过CPUID.01h:EDX[5]来检测处理器是否支持MSR寄存器组。值得注意的是，每种处理器家族都有自己的MSR寄存器组，我们在使用MSR寄存器组前需要根据处理器家族信息（通过CPUID.01h查询处理器家族信息）选择与之相对应的MSR寄存器组。

处理器可以使用指令RDMSR和WRMSR对MSR寄存器组进行访问，整个访问过程借助ECX寄存器索引寄存器地址，再由EDX:EAX组成的64位寄存器保持访问值。（在处理器支持64位模式下，RCX、RAX和RDX寄存器的高32位将会被忽略。）而且这对指令必须在实模式或0特权级下执行，否则将会触发#GP异常，使用MSR寄存器组的保留地址或无效地址都会产生通用保护异常。


<div id=c2><h2>地址空间</h2></div>






































