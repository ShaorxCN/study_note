CPU Exception
cpu异常

CPU exceptions occur in various erroneous situations, 
for example, when accessing an invalid memory address or when dividing by zero. 
To react to them, we have to set up an interrupt descriptor table that provides handler functions. 
At the end of this post, our kernel will be able to catch breakpoint exceptions and resume normal execution afterward.

cpu异常发生在各种错误的的场景。比如,当我们尝试去访问无效的内存地址或者除零的时候。为了对他们做出反应，我们需要设置中断描述符表来提供对应的处理函数。
在本章的最后，我们的内核将能够捕捉到断点异常，并在之后恢复到正常的执行环境。

This blog is openly developed on GitHub. If you have any problems or questions, please open an issue there. 
You can also leave comments at the bottom. 
The complete source code for this post can be found in the post-05 branch.
这篇博客是在GitHub上公开开发的。如果你有任何问题或疑问，请在那里开一个问题。你也可以在底部留下评论。
本帖的完整源代码可以在post-05分支中找到。

Overview
概述
An exception signals that something is wrong with the current instruction. 
For example, the CPU issues an exception if the current instruction tries to divide by 0. 
When an exception occurs, the CPU interrupts its current work and immediately calls a specific exception handler function, 
depending on the exception type.

当当前指令发生错误的时候就会产生一个异常信号。举个例子，如果当前指令尝试除以0 cpu就会发出异常，当异常发生的时候，cpu会打断当前的工作并且根据
异常类型立刻调用指定的异常处理函数。


On x86, there are about 20 different CPU exception types. The most important are:

Page  Fault:    A page fault occurs on illegal memory accesses.
                For example, if the current instruction tries to read from an unmapped page or tries to write to a read-only page.
Invalid Opcode: This exception occurs when the current instruction is invalid, for example, 
                when we try to use new SSE instructions on an old CPU that does not support them.
General Protection Fault: This is the exception with the broadest range of causes.
                It occurs on various kinds of access violations, such as trying to execute a privileged instruction 
                in user-level code or writing reserved fields in configuration registers.
Double Fault:   When an exception occurs, the CPU tries to call the corresponding handler function. 
                If another exception occurs while calling the exception handler, the CPU raises a double fault exception. 
                This exception also occurs when there is no handler function registered for an exception.
Triple Fault:   If an exception occurs while the CPU tries to call the double fault handler function,
                it issues a fatal triple fault. We can’t catch or handle a triple fault. 
                Most processors react by resetting themselves and rebooting the operating system.

For the full list of exceptions, check out the OSDev wiki.

在x86架构下 大约有20种cpu异常类型，其中一些最重要的如下：
页错误： 页错误是非法的内存访问引起的。举个例子，当前指令尝试从一个未映射的页读取数据或者是尝试往一个只读的页写入数据
非法的操作码:这种异常一般是当前的操作指令是非法的。举个例子:当我们尝试在不支持新SSE指令的老实cpu上使用这些指令的时候。
一般保护错误: 这是一个原因范围很广的异常，他发生在各种违反规定情况下的访问尝试，比如在用户层代码种尝试使用特权级指令或者尝试在配置寄存器种写入保留字段
双重故障:当一个异常出现时，cpu会尝试调用对应的异常处理函数。但是如果在调用异常处理函数的过程中，又产生了一个异常，这时候cpu就会发起一个双重故障异常。
        当没有注册对应异常处理函数的异常出现的时候，也会产生这个异常。
三重故障:如果cpu在调用双重异常处理函数的时候又产生了一个异常，那么就会发出三重故障异常，我们无法捕捉或者处理该异常，大多数处理器在这时候会重置自己或者重启操作系统

完整的异常列表 可以访问这个wiki: https://wiki.osdev.org/Exceptions

The Interrupt Descriptor Table
In order to catch and handle exceptions, we have to set up a so-called Interrupt Descriptor Table (IDT). 
In this table, we can specify a handler function for each CPU exception. The hardware uses this table directly, 
so we need to follow a predefined format. Each entry must have the following 16-byte structure:

中断描述符表
为了捕捉并且处理出现的异常，我们需要预先设置好一个叫做中断描述符表的东西。在这张表里，我们为每种cpu异常指定了处理函数。为了硬件可以直接使用
这张表，我们需要按照预先定义的格式来设置这张表。每个条目都必须包含以下的16字节的结构(图见原文)
[这是基于x86_64的,GDT用于分段管理(找到线性地址 段:偏移) LDT分页管理(找到物理地址)]


Type	Name	                       Description
u16	Function Pointer [0:15]	       The lower bits of the pointer to the handler function.
u16	GDT selector	               Selector of a code segment in the global descriptor table.
u16	Options	                       (see below)
u16	Function Pointer [16:31]       The middle bits of the pointer to the handler function.
u32	Function Pointer [32:63]       The remaining bits of the pointer to the handler function.
u32	Reserved

第1，2个字节       指向处理函数的指针的低16位
第3，4个字节       GDT中的段选择子 获得段地址
第5，6个字节       可选项 具体说明如下

Bits	Name	                                       Description
0-2	Interrupt Stack Table Index	               0: Don’t switch stacks, 1-7: Switch to the n-th stack in the Interrupt Stack Table when this handler is called.
3-7	Reserved	
8	0: Interrupt Gate, 1: Trap Gate	               If this bit is 0, interrupts are disabled when this handler is called.
9-11	must be one	
12	must be zero	
13‑14	Descriptor Privilege Level (DPL)	       The minimal privilege level required for calling this handler.
15	Present	



第7，8个字节            函数指针的中间部分
第9，10，11，12个字节   函数指针的剩余部分
最后四个字节            保留字节





